Q1: We save bits 20-16 and 15-11 of the instruction because we do not know 
which of these bits we would use to decide the writeback register. We would 
have to wait till the EX stage when the instruction decode is completed to 
figure this out. It is a waste of space to save the whole instruction. We could
achieved the same effects by saving the control signals.

Q2:
- EX: 
We need to use ALUSrc, ALUOp, and RegDst immediately in the EX stage, and we do
not need to use them later in other stages. Therefore, they are EX signals.
- M:
We do not need to use MemWrite, MemRead or Brach signals until the MEM stage, 
and we need to save them till the MEM stage. Therefore, they are MEM signals.
- WB:
We do not need to use MemtoReg or RegWrite signals until the WB stage, and we
need to save them till the WB stage. Therefore, they are WB signals.

Test Code 1:
Q3:
The program loads the word in memory address 0 to $t1. The next instruction
save what is in $t1 to memory address 0.
Q4:
The code produce the expected result.

Test Code 2:
Q3: 
The program first loads the word in memory address 0 + 0 to the register $t1.
The next instruction then writes the content of register $t1 to memory address 12 + 0 = 12 
(which is also the fourth word in the memory). 

Q4/5:
It does "work" on the pipelined processor, but it does not produce the expected result.
Since the pipelined processor takes more than one cycle to actually write it's result to the RF.
This is a Data hazard, we have the data in the Execution stage, but not in the register where we need it.

Q6:
To make the code behave the way the programmer intent we need to add "stalls" (NOPs).
This will give the loaded data time to be written to the RF.
The RF is singlepumped so we need four cycles (four NOPs).

Test Code 3:
Q3:
The program first loads the word in memory address 0 to register $t1.
Then it loads the word in memory address 4 (2nd word in memory) to register $t2.
Then it adds the words in $t1 and $t2 and save the result in $t3.
Then it adds the words in $t1 and $t3 and save the result in $t3.
In the end it saves the word in $t3 to memory address 12 (4th word in memory).

Q4:
It does not work.

Q5:
The data from memory address 0 and 4 has not been written back to the register
file yet at the point when the next add instruction is reading the register
file. 
The second add instruction tries to use the result from the first add
instruction, but the result has not been written back to the register file.
The sw instruction tries to use the result from the second add instruction, but
the result has not been written back to the register file.

Q6:
We insert 3 nops after the second lw,
          3 nops after the first add,
          3 nops after the second add.
